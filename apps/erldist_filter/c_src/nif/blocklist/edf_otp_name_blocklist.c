// DO NOT EDIT: this file was generated by 'just codegen'
// @generated SignedSource<<2f446c67b2c4e9a1aae2e1a4199522e5>>
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * Copyright (c) WhatsApp LLC
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 */

#include "edf_otp_name_blocklist.h"

#include "../core/khashl.h"

/* Type Definitions */

typedef uintptr_t edf_otp_name_blocklist_hs_key_t;
static khint_t edf_otp_name_blocklist_hs_key_hash_fn(edf_otp_name_blocklist_hs_key_t key);
static bool edf_otp_name_blocklist_hs_key_hash_eq(edf_otp_name_blocklist_hs_key_t k1, edf_otp_name_blocklist_hs_key_t k2);

KHASHL_SET_INIT(KH_LOCAL, edf_otp_name_blocklist_hs_t, edf_otp_name_blocklist_hs, edf_otp_name_blocklist_hs_key_t,
                edf_otp_name_blocklist_hs_key_hash_fn, edf_otp_name_blocklist_hs_key_hash_eq)

struct edf_otp_name_blocklist_s {
    edf_otp_name_blocklist_hs_t *hs;
};

/* Global Variables */

static atomic_flag edf_otp_name_blocklist_initialized = ATOMIC_FLAG_INIT;
static edf_otp_name_blocklist_t edf_otp_name_blocklist_internal = {.hs = NULL};
edf_otp_name_blocklist_t *edf_otp_name_blocklist = &edf_otp_name_blocklist_internal;

/* Static Declarations */

/* Function Definitions */

int
edf_otp_name_blocklist_load(ErlNifEnv *env)
{
#define BLOCK_NAME(atom)                                                                                                           \
    do {                                                                                                                           \
        (void)edf_otp_name_blocklist_hs_put(edf_otp_name_blocklist->hs, (edf_otp_name_blocklist_hs_key_t)(atom), &absent);         \
        if (absent != 1) {                                                                                                         \
            (void)enif_fprintf(stderr, "Failed to add %T to OTP name blocklist\n", atom);                                          \
            goto destroy;                                                                                                          \
        }                                                                                                                          \
    } while (0)

    int retval = 0;
    int absent = -1;

    if (!atomic_flag_test_and_set(&edf_otp_name_blocklist_initialized)) {
        if (edf_otp_name_blocklist->hs == NULL) {
            edf_otp_name_blocklist->hs = edf_otp_name_blocklist_hs_init();
            if (edf_otp_name_blocklist->hs == NULL)
                goto failure;
            BLOCK_NAME(ATOM(alarm_handler));
            BLOCK_NAME(ATOM(application_controller));
            BLOCK_NAME(ATOM(appmon_info));
            BLOCK_NAME(ATOM(asn1_driver_owner));
            BLOCK_NAME(ATOM(auth));
            BLOCK_NAME(ATOM(beam_lib__crypto_key_server));
            BLOCK_NAME(ATOM(boot_server));
            BLOCK_NAME(ATOM(code_server));
            BLOCK_NAME(ATOM(compl_pid));
            BLOCK_NAME(ATOM(cpu_sup));
            BLOCK_NAME(ATOM(crashdump_viewer));
            BLOCK_NAME(ATOM(ct_config_server));
            BLOCK_NAME(ATOM(ct_default_gl));
            BLOCK_NAME(ATOM(ct_event));
            BLOCK_NAME(ATOM(ct_hooks_lock));
            BLOCK_NAME(ATOM(ct_logs));
            BLOCK_NAME(ATOM(ct_master));
            BLOCK_NAME(ATOM(ct_master_event));
            BLOCK_NAME(ATOM(ct_master_logs));
            BLOCK_NAME(ATOM(ct_util_server));
            BLOCK_NAME(ATOM(cth_log_redirect));
            BLOCK_NAME(ATOM(dbg));
            BLOCK_NAME(ATOM(dbg_iserver));
            BLOCK_NAME(ATOM(dbg_wx_winman));
            BLOCK_NAME(ATOM(dets_server));
            BLOCK_NAME(ATOM(dets_sup));
            BLOCK_NAME(ATOM(diameter_config));
            BLOCK_NAME(ATOM(diameter_config_sup));
            BLOCK_NAME(ATOM(diameter_dist));
            BLOCK_NAME(ATOM(diameter_etcp_sup));
            BLOCK_NAME(ATOM(diameter_event_logger));
            BLOCK_NAME(ATOM(diameter_misc_sup));
            BLOCK_NAME(ATOM(diameter_peer));
            BLOCK_NAME(ATOM(diameter_peer_fsm_sup));
            BLOCK_NAME(ATOM(diameter_reg));
            BLOCK_NAME(ATOM(diameter_sctp_sup));
            BLOCK_NAME(ATOM(diameter_service_sup));
            BLOCK_NAME(ATOM(diameter_stats));
            BLOCK_NAME(ATOM(diameter_sup));
            BLOCK_NAME(ATOM(diameter_sync));
            BLOCK_NAME(ATOM(diameter_tcp_sup));
            BLOCK_NAME(ATOM(diameter_transport_sup));
            BLOCK_NAME(ATOM(disk_log_server));
            BLOCK_NAME(ATOM(disk_log_sup));
            BLOCK_NAME(ATOM(disksup));
            BLOCK_NAME(ATOM(dist_ac));
            BLOCK_NAME(ATOM(drv_complete));
            BLOCK_NAME(ATOM(dtls_connection_sup));
            BLOCK_NAME(ATOM(dtls_connection_sup_dist));
            BLOCK_NAME(ATOM(dtls_listener_sup));
            BLOCK_NAME(ATOM(dtls_server_session_cache_sup));
            BLOCK_NAME(ATOM(dtls_server_sup));
            BLOCK_NAME(ATOM(dtls_sup));
            BLOCK_NAME(ATOM(eprof));
            BLOCK_NAME(ATOM(erl_compile_server));
            BLOCK_NAME(ATOM(erl_epmd));
            BLOCK_NAME(ATOM(erl_prim_loader));
            BLOCK_NAME(ATOM(erl_signal_server));
            BLOCK_NAME(ATOM(error_logger));
            BLOCK_NAME(ATOM(erts_code_purger));
            BLOCK_NAME(ATOM(file_server));
            BLOCK_NAME(ATOM(file_server_2));
            BLOCK_NAME(ATOM(ftp_sup));
            BLOCK_NAME(ATOM(global));
            BLOCK_NAME(ATOM(global_group));
            BLOCK_NAME(ATOM(global_group_check));
            BLOCK_NAME(ATOM(global_name_server));
            BLOCK_NAME(ATOM(group));
            BLOCK_NAME(ATOM(httpc_handler_sup));
            BLOCK_NAME(ATOM(httpc_manager));
            BLOCK_NAME(ATOM(httpc_profile_sup));
            BLOCK_NAME(ATOM(httpc_sup));
            BLOCK_NAME(ATOM(httpd_acceptor_sup));
            BLOCK_NAME(ATOM(httpd_sup));
            BLOCK_NAME(ATOM(httpd_tester));
            BLOCK_NAME(ATOM(inet_db));
            BLOCK_NAME(ATOM(inet_gethost_native));
            BLOCK_NAME(ATOM(inet_gethost_native_sup));
            BLOCK_NAME(ATOM(inets_sup));
            BLOCK_NAME(ATOM(init));
            BLOCK_NAME(ATOM(init__boot__on_load_handler));
            BLOCK_NAME(ATOM(kernel_refc));
            BLOCK_NAME(ATOM(kernel_safe_sup));
            BLOCK_NAME(ATOM(kernel_sup));
            BLOCK_NAME(ATOM(lcnt));
            BLOCK_NAME(ATOM(logger));
            BLOCK_NAME(ATOM(logger_handler_watcher));
            BLOCK_NAME(ATOM(logger_proxy));
            BLOCK_NAME(ATOM(logger_server));
            BLOCK_NAME(ATOM(logger_simple_h));
            BLOCK_NAME(ATOM(logger_std_h_default));
            BLOCK_NAME(ATOM(logger_sup));
            BLOCK_NAME(ATOM(megaco_misc_sup));
            BLOCK_NAME(ATOM(megaco_monitor));
            BLOCK_NAME(ATOM(megaco_sup));
            BLOCK_NAME(ATOM(megaco_trans_sup));
            BLOCK_NAME(ATOM(memsup));
            BLOCK_NAME(ATOM(mnesia_checkpoint_sup));
            BLOCK_NAME(ATOM(mnesia_controller));
            BLOCK_NAME(ATOM(mnesia_dumper_load_regulator));
            BLOCK_NAME(ATOM(mnesia_event));
            BLOCK_NAME(ATOM(mnesia_ext_sup));
            BLOCK_NAME(ATOM(mnesia_fallback));
            BLOCK_NAME(ATOM(mnesia_kernel_sup));
            BLOCK_NAME(ATOM(mnesia_late_loader));
            BLOCK_NAME(ATOM(mnesia_locker));
            BLOCK_NAME(ATOM(mnesia_monitor));
            BLOCK_NAME(ATOM(mnesia_recover));
            BLOCK_NAME(ATOM(mnesia_rpc));
            BLOCK_NAME(ATOM(mnesia_snmp_sup));
            BLOCK_NAME(ATOM(mnesia_subscr));
            BLOCK_NAME(ATOM(mnesia_sup));
            BLOCK_NAME(ATOM(mnesia_tm));
            BLOCK_NAME(ATOM(net_sup));
            BLOCK_NAME(ATOM(nteventlog));
            BLOCK_NAME(ATOM(odbc_sup));
            BLOCK_NAME(ATOM(os_mon_sup));
            BLOCK_NAME(ATOM(os_mon_sysinfo));
            BLOCK_NAME(ATOM(os_sup_server));
            BLOCK_NAME(ATOM(peer_supervision));
            BLOCK_NAME(ATOM(rb_server));
            BLOCK_NAME(ATOM(release_handler));
            BLOCK_NAME(ATOM(runtime_tools_sup));
            BLOCK_NAME(ATOM(sasl_safe_sup));
            BLOCK_NAME(ATOM(sasl_sup));
            BLOCK_NAME(ATOM(shell));
            BLOCK_NAME(ATOM(socket_registry));
            BLOCK_NAME(ATOM(snmp_app_sup));
            BLOCK_NAME(ATOM(snmp_ex2_manager));
            BLOCK_NAME(ATOM(snmp_test_manager));
            BLOCK_NAME(ATOM(snmp_test_mgr));
            BLOCK_NAME(ATOM(snmpa_agent));
            BLOCK_NAME(ATOM(snmpa_local_db));
            BLOCK_NAME(ATOM(snmpa_misc_sup));
            BLOCK_NAME(ATOM(snmpa_supervisor));
            BLOCK_NAME(ATOM(snmpa_symbolic_store));
            BLOCK_NAME(ATOM(snmpa_target_cache));
            BLOCK_NAME(ATOM(snmpm_config));
            BLOCK_NAME(ATOM(snmpm_misc_sup));
            BLOCK_NAME(ATOM(snmpm_server));
            BLOCK_NAME(ATOM(snmpm_server_sup));
            BLOCK_NAME(ATOM(snmpm_supervisor));
            BLOCK_NAME(ATOM(ssh_dbg));
            BLOCK_NAME(ATOM(ssh_lsocket_sup));
            BLOCK_NAME(ATOM(ssh_sup));
            BLOCK_NAME(ATOM(ssl_admin_sup));
            BLOCK_NAME(ATOM(ssl_connection_sup));
            BLOCK_NAME(ATOM(ssl_dist_admin_sup));
            BLOCK_NAME(ATOM(ssl_dist_connection_sup));
            BLOCK_NAME(ATOM(ssl_dist_sup));
            BLOCK_NAME(ATOM(ssl_listen_tracker_sup));
            BLOCK_NAME(ATOM(ssl_listen_tracker_sup_dist));
            BLOCK_NAME(ATOM(ssl_manager));
            BLOCK_NAME(ATOM(ssl_manager_dist));
            BLOCK_NAME(ATOM(ssl_pem_cache));
            BLOCK_NAME(ATOM(ssl_pem_cache_dist));
            BLOCK_NAME(ATOM(ssl_server_session_cache_sup));
            BLOCK_NAME(ATOM(ssl_sup));
            BLOCK_NAME(ATOM(ssl_trace));
            BLOCK_NAME(ATOM(ssl_unknown_listener));
            BLOCK_NAME(ATOM(ssl_upgrade_server_session_cache_sup));
            BLOCK_NAME(ATOM(ssl_upgrade_server_session_cache_sup_dist));
            BLOCK_NAME(ATOM(standard_error));
            BLOCK_NAME(ATOM(standard_error_sup));
            BLOCK_NAME(ATOM(standard_error_writer));
            BLOCK_NAME(ATOM(system_information));
            BLOCK_NAME(ATOM(test_server_ctrl));
            BLOCK_NAME(ATOM(test_server_io));
            BLOCK_NAME(ATOM(test_server_sup));
            BLOCK_NAME(ATOM(tftp_sup));
            BLOCK_NAME(ATOM(timer_server));
            BLOCK_NAME(ATOM(tls_client_ticket_store));
            BLOCK_NAME(ATOM(tls_connection_sup));
            BLOCK_NAME(ATOM(tls_dist_connection_sup));
            BLOCK_NAME(ATOM(tls_dist_server_sup));
            BLOCK_NAME(ATOM(tls_dist_sup));
            BLOCK_NAME(ATOM(tls_server_session_ticket_sup));
            BLOCK_NAME(ATOM(tls_server_session_ticket_sup_dist));
            BLOCK_NAME(ATOM(tls_server_sup));
            BLOCK_NAME(ATOM(tls_sup));
            BLOCK_NAME(ATOM(tprof));
            BLOCK_NAME(ATOM(user));
            BLOCK_NAME(ATOM(user_drv));
            BLOCK_NAME(ATOM(user_drv_reader));
            BLOCK_NAME(ATOM(user_drv_writer));
            BLOCK_NAME(ATOM(wxe_master));
        }
    }

    return retval;

destroy:
    (void)edf_otp_name_blocklist_hs_destroy(edf_otp_name_blocklist->hs);
    edf_otp_name_blocklist->hs = NULL;
failure:
    (void)atomic_flag_clear(&edf_otp_name_blocklist_initialized);
    retval = -1;
    return retval;

#undef BLOCK_NAME
}

void
edf_otp_name_blocklist_unload(ErlNifEnv *env)
{
    (void)env;
    if (edf_otp_name_blocklist->hs != NULL) {
        (void)edf_otp_name_blocklist_hs_destroy(edf_otp_name_blocklist->hs);
        edf_otp_name_blocklist->hs = NULL;
        (void)atomic_flag_clear(&edf_otp_name_blocklist_initialized);
    }
    return;
}

bool
edf_otp_name_is_blocked(ERL_NIF_TERM name)
{
    return (edf_otp_name_blocklist_hs_get(edf_otp_name_blocklist->hs, (edf_otp_name_blocklist_hs_key_t)(name)) <
            kh_end(edf_otp_name_blocklist->hs));
}

ERL_NIF_TERM
erldist_filter_nif_otp_name_blocklist_0(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
#define NUMBER_OF_OTP_NAME_BLOCKLIST (186)

    ERL_NIF_TERM out_term;
    ERL_NIF_TERM atoms[NUMBER_OF_OTP_NAME_BLOCKLIST];
    size_t i = 0;

    if (argc != 0) {
        return EXCP_BADARG(env, "argc must be 0");
    }

    atoms[i++] = ATOM(alarm_handler);
    atoms[i++] = ATOM(application_controller);
    atoms[i++] = ATOM(appmon_info);
    atoms[i++] = ATOM(asn1_driver_owner);
    atoms[i++] = ATOM(auth);
    atoms[i++] = ATOM(beam_lib__crypto_key_server);
    atoms[i++] = ATOM(boot_server);
    atoms[i++] = ATOM(code_server);
    atoms[i++] = ATOM(compl_pid);
    atoms[i++] = ATOM(cpu_sup);
    atoms[i++] = ATOM(crashdump_viewer);
    atoms[i++] = ATOM(ct_config_server);
    atoms[i++] = ATOM(ct_default_gl);
    atoms[i++] = ATOM(ct_event);
    atoms[i++] = ATOM(ct_hooks_lock);
    atoms[i++] = ATOM(ct_logs);
    atoms[i++] = ATOM(ct_master);
    atoms[i++] = ATOM(ct_master_event);
    atoms[i++] = ATOM(ct_master_logs);
    atoms[i++] = ATOM(ct_util_server);
    atoms[i++] = ATOM(cth_log_redirect);
    atoms[i++] = ATOM(dbg);
    atoms[i++] = ATOM(dbg_iserver);
    atoms[i++] = ATOM(dbg_wx_winman);
    atoms[i++] = ATOM(dets_server);
    atoms[i++] = ATOM(dets_sup);
    atoms[i++] = ATOM(diameter_config);
    atoms[i++] = ATOM(diameter_config_sup);
    atoms[i++] = ATOM(diameter_dist);
    atoms[i++] = ATOM(diameter_etcp_sup);
    atoms[i++] = ATOM(diameter_event_logger);
    atoms[i++] = ATOM(diameter_misc_sup);
    atoms[i++] = ATOM(diameter_peer);
    atoms[i++] = ATOM(diameter_peer_fsm_sup);
    atoms[i++] = ATOM(diameter_reg);
    atoms[i++] = ATOM(diameter_sctp_sup);
    atoms[i++] = ATOM(diameter_service_sup);
    atoms[i++] = ATOM(diameter_stats);
    atoms[i++] = ATOM(diameter_sup);
    atoms[i++] = ATOM(diameter_sync);
    atoms[i++] = ATOM(diameter_tcp_sup);
    atoms[i++] = ATOM(diameter_transport_sup);
    atoms[i++] = ATOM(disk_log_server);
    atoms[i++] = ATOM(disk_log_sup);
    atoms[i++] = ATOM(disksup);
    atoms[i++] = ATOM(dist_ac);
    atoms[i++] = ATOM(drv_complete);
    atoms[i++] = ATOM(dtls_connection_sup);
    atoms[i++] = ATOM(dtls_connection_sup_dist);
    atoms[i++] = ATOM(dtls_listener_sup);
    atoms[i++] = ATOM(dtls_server_session_cache_sup);
    atoms[i++] = ATOM(dtls_server_sup);
    atoms[i++] = ATOM(dtls_sup);
    atoms[i++] = ATOM(eprof);
    atoms[i++] = ATOM(erl_compile_server);
    atoms[i++] = ATOM(erl_epmd);
    atoms[i++] = ATOM(erl_prim_loader);
    atoms[i++] = ATOM(erl_signal_server);
    atoms[i++] = ATOM(error_logger);
    atoms[i++] = ATOM(erts_code_purger);
    atoms[i++] = ATOM(file_server);
    atoms[i++] = ATOM(file_server_2);
    atoms[i++] = ATOM(ftp_sup);
    atoms[i++] = ATOM(global);
    atoms[i++] = ATOM(global_group);
    atoms[i++] = ATOM(global_group_check);
    atoms[i++] = ATOM(global_name_server);
    atoms[i++] = ATOM(group);
    atoms[i++] = ATOM(httpc_handler_sup);
    atoms[i++] = ATOM(httpc_manager);
    atoms[i++] = ATOM(httpc_profile_sup);
    atoms[i++] = ATOM(httpc_sup);
    atoms[i++] = ATOM(httpd_acceptor_sup);
    atoms[i++] = ATOM(httpd_sup);
    atoms[i++] = ATOM(httpd_tester);
    atoms[i++] = ATOM(inet_db);
    atoms[i++] = ATOM(inet_gethost_native);
    atoms[i++] = ATOM(inet_gethost_native_sup);
    atoms[i++] = ATOM(inets_sup);
    atoms[i++] = ATOM(init);
    atoms[i++] = ATOM(init__boot__on_load_handler);
    atoms[i++] = ATOM(kernel_refc);
    atoms[i++] = ATOM(kernel_safe_sup);
    atoms[i++] = ATOM(kernel_sup);
    atoms[i++] = ATOM(lcnt);
    atoms[i++] = ATOM(logger);
    atoms[i++] = ATOM(logger_handler_watcher);
    atoms[i++] = ATOM(logger_proxy);
    atoms[i++] = ATOM(logger_server);
    atoms[i++] = ATOM(logger_simple_h);
    atoms[i++] = ATOM(logger_std_h_default);
    atoms[i++] = ATOM(logger_sup);
    atoms[i++] = ATOM(megaco_misc_sup);
    atoms[i++] = ATOM(megaco_monitor);
    atoms[i++] = ATOM(megaco_sup);
    atoms[i++] = ATOM(megaco_trans_sup);
    atoms[i++] = ATOM(memsup);
    atoms[i++] = ATOM(mnesia_checkpoint_sup);
    atoms[i++] = ATOM(mnesia_controller);
    atoms[i++] = ATOM(mnesia_dumper_load_regulator);
    atoms[i++] = ATOM(mnesia_event);
    atoms[i++] = ATOM(mnesia_ext_sup);
    atoms[i++] = ATOM(mnesia_fallback);
    atoms[i++] = ATOM(mnesia_kernel_sup);
    atoms[i++] = ATOM(mnesia_late_loader);
    atoms[i++] = ATOM(mnesia_locker);
    atoms[i++] = ATOM(mnesia_monitor);
    atoms[i++] = ATOM(mnesia_recover);
    atoms[i++] = ATOM(mnesia_rpc);
    atoms[i++] = ATOM(mnesia_snmp_sup);
    atoms[i++] = ATOM(mnesia_subscr);
    atoms[i++] = ATOM(mnesia_sup);
    atoms[i++] = ATOM(mnesia_tm);
    atoms[i++] = ATOM(net_sup);
    atoms[i++] = ATOM(nteventlog);
    atoms[i++] = ATOM(odbc_sup);
    atoms[i++] = ATOM(os_mon_sup);
    atoms[i++] = ATOM(os_mon_sysinfo);
    atoms[i++] = ATOM(os_sup_server);
    atoms[i++] = ATOM(peer_supervision);
    atoms[i++] = ATOM(rb_server);
    atoms[i++] = ATOM(release_handler);
    atoms[i++] = ATOM(runtime_tools_sup);
    atoms[i++] = ATOM(sasl_safe_sup);
    atoms[i++] = ATOM(sasl_sup);
    atoms[i++] = ATOM(shell);
    atoms[i++] = ATOM(socket_registry);
    atoms[i++] = ATOM(snmp_app_sup);
    atoms[i++] = ATOM(snmp_ex2_manager);
    atoms[i++] = ATOM(snmp_test_manager);
    atoms[i++] = ATOM(snmp_test_mgr);
    atoms[i++] = ATOM(snmpa_agent);
    atoms[i++] = ATOM(snmpa_local_db);
    atoms[i++] = ATOM(snmpa_misc_sup);
    atoms[i++] = ATOM(snmpa_supervisor);
    atoms[i++] = ATOM(snmpa_symbolic_store);
    atoms[i++] = ATOM(snmpa_target_cache);
    atoms[i++] = ATOM(snmpm_config);
    atoms[i++] = ATOM(snmpm_misc_sup);
    atoms[i++] = ATOM(snmpm_server);
    atoms[i++] = ATOM(snmpm_server_sup);
    atoms[i++] = ATOM(snmpm_supervisor);
    atoms[i++] = ATOM(ssh_dbg);
    atoms[i++] = ATOM(ssh_lsocket_sup);
    atoms[i++] = ATOM(ssh_sup);
    atoms[i++] = ATOM(ssl_admin_sup);
    atoms[i++] = ATOM(ssl_connection_sup);
    atoms[i++] = ATOM(ssl_dist_admin_sup);
    atoms[i++] = ATOM(ssl_dist_connection_sup);
    atoms[i++] = ATOM(ssl_dist_sup);
    atoms[i++] = ATOM(ssl_listen_tracker_sup);
    atoms[i++] = ATOM(ssl_listen_tracker_sup_dist);
    atoms[i++] = ATOM(ssl_manager);
    atoms[i++] = ATOM(ssl_manager_dist);
    atoms[i++] = ATOM(ssl_pem_cache);
    atoms[i++] = ATOM(ssl_pem_cache_dist);
    atoms[i++] = ATOM(ssl_server_session_cache_sup);
    atoms[i++] = ATOM(ssl_sup);
    atoms[i++] = ATOM(ssl_trace);
    atoms[i++] = ATOM(ssl_unknown_listener);
    atoms[i++] = ATOM(ssl_upgrade_server_session_cache_sup);
    atoms[i++] = ATOM(ssl_upgrade_server_session_cache_sup_dist);
    atoms[i++] = ATOM(standard_error);
    atoms[i++] = ATOM(standard_error_sup);
    atoms[i++] = ATOM(standard_error_writer);
    atoms[i++] = ATOM(system_information);
    atoms[i++] = ATOM(test_server_ctrl);
    atoms[i++] = ATOM(test_server_io);
    atoms[i++] = ATOM(test_server_sup);
    atoms[i++] = ATOM(tftp_sup);
    atoms[i++] = ATOM(timer_server);
    atoms[i++] = ATOM(tls_client_ticket_store);
    atoms[i++] = ATOM(tls_connection_sup);
    atoms[i++] = ATOM(tls_dist_connection_sup);
    atoms[i++] = ATOM(tls_dist_server_sup);
    atoms[i++] = ATOM(tls_dist_sup);
    atoms[i++] = ATOM(tls_server_session_ticket_sup);
    atoms[i++] = ATOM(tls_server_session_ticket_sup_dist);
    atoms[i++] = ATOM(tls_server_sup);
    atoms[i++] = ATOM(tls_sup);
    atoms[i++] = ATOM(tprof);
    atoms[i++] = ATOM(user);
    atoms[i++] = ATOM(user_drv);
    atoms[i++] = ATOM(user_drv_reader);
    atoms[i++] = ATOM(user_drv_writer);
    atoms[i++] = ATOM(wxe_master);

    out_term = enif_make_list_from_array(env, atoms, NUMBER_OF_OTP_NAME_BLOCKLIST);
    return out_term;
#undef NUMBER_OF_OTP_NAME_BLOCKLIST
}

ERL_NIF_TERM
erldist_filter_nif_otp_name_is_blocked_1(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    ERL_NIF_TERM name;

    if (argc != 1) {
        return EXCP_BADARG(env, "argc must be 0");
    }

    name = argv[0];

    if (edf_otp_name_is_blocked(name)) {
        return ATOM(true);
    } else {
        return ATOM(false);
    }
}

inline khint_t
edf_otp_name_blocklist_hs_key_hash_fn(edf_otp_name_blocklist_hs_key_t key)
{
    return (khint_t)((key * 0x9e3779b97f4a7c15ULL) >> 32);
}

inline bool
edf_otp_name_blocklist_hs_key_hash_eq(edf_otp_name_blocklist_hs_key_t k1, edf_otp_name_blocklist_hs_key_t k2)
{
    return (k1 == k2);
}
