// DO NOT EDIT: this file was generated by 'just codegen'
// @generated SignedSource<<d850859cf4f6d474c5cf7deac77848f8>>
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * Copyright (c) WhatsApp LLC
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 */

#include "edf_erts_dist_impl.h"

#include <stdbool.h>
#include <unistd.h>

#include "../erts/dist.h"

/* NIF Function Definitions */

ERL_NIF_TERM
erldist_filter_nif_altact_sig_flags_0(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
#define NUMBER_OF_ALTACT_SIG_FLAGS (5)
    ERL_NIF_TERM keys[NUMBER_OF_ALTACT_SIG_FLAGS];
    ERL_NIF_TERM vals[NUMBER_OF_ALTACT_SIG_FLAGS];
    size_t k = 0;
    size_t v = 0;
    ERL_NIF_TERM out_term;

    if (argc != 0) {
        return EXCP_BADARG(env, "argc must be 0");
    }
    keys[k++] = ATOM(ERTS_DOP_ALTACT_SIG_FLG_PRIO);
    vals[v++] = enif_make_uint64(env, ERTS_DOP_ALTACT_SIG_FLG_PRIO);
    keys[k++] = ATOM(ERTS_DOP_ALTACT_SIG_FLG_TOKEN);
    vals[v++] = enif_make_uint64(env, ERTS_DOP_ALTACT_SIG_FLG_TOKEN);
    keys[k++] = ATOM(ERTS_DOP_ALTACT_SIG_FLG_ALIAS);
    vals[v++] = enif_make_uint64(env, ERTS_DOP_ALTACT_SIG_FLG_ALIAS);
    keys[k++] = ATOM(ERTS_DOP_ALTACT_SIG_FLG_NAME);
    vals[v++] = enif_make_uint64(env, ERTS_DOP_ALTACT_SIG_FLG_NAME);
    keys[k++] = ATOM(ERTS_DOP_ALTACT_SIG_FLG_EXIT);
    vals[v++] = enif_make_uint64(env, ERTS_DOP_ALTACT_SIG_FLG_EXIT);

    if (!enif_make_map_from_arrays(env, keys, vals, NUMBER_OF_ALTACT_SIG_FLAGS, &out_term)) {
        return EXCP_ERROR(env, "Call to enif_make_map_from_arrays() failed: duplicate keys detected");
    }

#undef NUMBER_OF_ALTACT_SIG_FLAGS
    return out_term;
}

ERL_NIF_TERM
erldist_filter_nif_distribution_flags_0(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
#define NUMBER_OF_DISTRIBUTION_FLAGS (44)
    ERL_NIF_TERM keys[NUMBER_OF_DISTRIBUTION_FLAGS];
    ERL_NIF_TERM vals[NUMBER_OF_DISTRIBUTION_FLAGS];
    size_t k = 0;
    size_t v = 0;
    ERL_NIF_TERM out_term;

    if (argc != 0) {
        return EXCP_BADARG(env, "argc must be 0");
    }
    keys[k++] = ATOM(DFLAG_PUBLISHED);
    vals[v++] = enif_make_uint64(env, DFLAG_PUBLISHED);
    keys[k++] = ATOM(DFLAG_ATOM_CACHE);
    vals[v++] = enif_make_uint64(env, DFLAG_ATOM_CACHE);
    keys[k++] = ATOM(DFLAG_EXTENDED_REFERENCES);
    vals[v++] = enif_make_uint64(env, DFLAG_EXTENDED_REFERENCES);
    keys[k++] = ATOM(DFLAG_DIST_MONITOR);
    vals[v++] = enif_make_uint64(env, DFLAG_DIST_MONITOR);
    keys[k++] = ATOM(DFLAG_FUN_TAGS);
    vals[v++] = enif_make_uint64(env, DFLAG_FUN_TAGS);
    keys[k++] = ATOM(DFLAG_DIST_MONITOR_NAME);
    vals[v++] = enif_make_uint64(env, DFLAG_DIST_MONITOR_NAME);
    keys[k++] = ATOM(DFLAG_HIDDEN_ATOM_CACHE);
    vals[v++] = enif_make_uint64(env, DFLAG_HIDDEN_ATOM_CACHE);
    keys[k++] = ATOM(DFLAG_NEW_FUN_TAGS);
    vals[v++] = enif_make_uint64(env, DFLAG_NEW_FUN_TAGS);
    keys[k++] = ATOM(DFLAG_EXTENDED_PIDS_PORTS);
    vals[v++] = enif_make_uint64(env, DFLAG_EXTENDED_PIDS_PORTS);
    keys[k++] = ATOM(DFLAG_EXPORT_PTR_TAG);
    vals[v++] = enif_make_uint64(env, DFLAG_EXPORT_PTR_TAG);
    keys[k++] = ATOM(DFLAG_BIT_BINARIES);
    vals[v++] = enif_make_uint64(env, DFLAG_BIT_BINARIES);
    keys[k++] = ATOM(DFLAG_NEW_FLOATS);
    vals[v++] = enif_make_uint64(env, DFLAG_NEW_FLOATS);
    keys[k++] = ATOM(DFLAG_UNICODE_IO);
    vals[v++] = enif_make_uint64(env, DFLAG_UNICODE_IO);
    keys[k++] = ATOM(DFLAG_DIST_HDR_ATOM_CACHE);
    vals[v++] = enif_make_uint64(env, DFLAG_DIST_HDR_ATOM_CACHE);
    keys[k++] = ATOM(DFLAG_SMALL_ATOM_TAGS);
    vals[v++] = enif_make_uint64(env, DFLAG_SMALL_ATOM_TAGS);
    keys[k++] = ATOM(DFLAG_ETS_COMPRESSED);
    vals[v++] = enif_make_uint64(env, DFLAG_ETS_COMPRESSED);
    keys[k++] = ATOM(DFLAG_UTF8_ATOMS);
    vals[v++] = enif_make_uint64(env, DFLAG_UTF8_ATOMS);
    keys[k++] = ATOM(DFLAG_MAP_TAG);
    vals[v++] = enif_make_uint64(env, DFLAG_MAP_TAG);
    keys[k++] = ATOM(DFLAG_BIG_CREATION);
    vals[v++] = enif_make_uint64(env, DFLAG_BIG_CREATION);
    keys[k++] = ATOM(DFLAG_SEND_SENDER);
    vals[v++] = enif_make_uint64(env, DFLAG_SEND_SENDER);
    keys[k++] = ATOM(DFLAG_BIG_SEQTRACE_LABELS);
    vals[v++] = enif_make_uint64(env, DFLAG_BIG_SEQTRACE_LABELS);
    keys[k++] = ATOM(DFLAG_PENDING_CONNECT);
    vals[v++] = enif_make_uint64(env, DFLAG_PENDING_CONNECT);
    keys[k++] = ATOM(DFLAG_EXIT_PAYLOAD);
    vals[v++] = enif_make_uint64(env, DFLAG_EXIT_PAYLOAD);
    keys[k++] = ATOM(DFLAG_FRAGMENTS);
    vals[v++] = enif_make_uint64(env, DFLAG_FRAGMENTS);
    keys[k++] = ATOM(DFLAG_HANDSHAKE_23);
    vals[v++] = enif_make_uint64(env, DFLAG_HANDSHAKE_23);
    keys[k++] = ATOM(DFLAG_UNLINK_ID);
    vals[v++] = enif_make_uint64(env, DFLAG_UNLINK_ID);
    keys[k++] = ATOM(DFLAG_MANDATORY_25_DIGEST);
    vals[v++] = enif_make_uint64(env, DFLAG_MANDATORY_25_DIGEST);
    keys[k++] = ATOM(DFLAG_RESERVED);
    vals[v++] = enif_make_uint64(env, DFLAG_RESERVED);
    keys[k++] = ATOM(DFLAG_SPAWN);
    vals[v++] = enif_make_uint64(env, DFLAG_SPAWN);
    keys[k++] = ATOM(DFLAG_NAME_ME);
    vals[v++] = enif_make_uint64(env, DFLAG_NAME_ME);
    keys[k++] = ATOM(DFLAG_V4_NC);
    vals[v++] = enif_make_uint64(env, DFLAG_V4_NC);
    keys[k++] = ATOM(DFLAG_ALIAS);
    vals[v++] = enif_make_uint64(env, DFLAG_ALIAS);
    keys[k++] = ATOM(DFLAG_LOCAL_EXT);
    vals[v++] = enif_make_uint64(env, DFLAG_LOCAL_EXT);
    keys[k++] = ATOM(DFLAG_ALTACT_SIG);
    vals[v++] = enif_make_uint64(env, DFLAG_ALTACT_SIG);
    keys[k++] = ATOM(DFLAG_DETERMINISTIC);
    vals[v++] = enif_make_uint64(env, DFLAG_DETERMINISTIC);
    keys[k++] = ATOM(DFLAG_DIST_MANDATORY_25);
    vals[v++] = enif_make_uint64(env, DFLAG_DIST_MANDATORY_25);
    keys[k++] = ATOM(DFLAG_DIST_MANDATORY_26);
    vals[v++] = enif_make_uint64(env, DFLAG_DIST_MANDATORY_26);
    keys[k++] = ATOM(DFLAG_DIST_MANDATORY);
    vals[v++] = enif_make_uint64(env, DFLAG_DIST_MANDATORY);
    keys[k++] = ATOM(DFLAG_DIST_HOPEFULLY);
    vals[v++] = enif_make_uint64(env, DFLAG_DIST_HOPEFULLY);
    keys[k++] = ATOM(DFLAG_DIST_DEFAULT);
    vals[v++] = enif_make_uint64(env, DFLAG_DIST_DEFAULT);
    keys[k++] = ATOM(DFLAG_DIST_ADDABLE);
    vals[v++] = enif_make_uint64(env, DFLAG_DIST_ADDABLE);
    keys[k++] = ATOM(DFLAG_DIST_REJECTABLE);
    vals[v++] = enif_make_uint64(env, DFLAG_DIST_REJECTABLE);
    keys[k++] = ATOM(DFLAG_DIST_STRICT_ORDER);
    vals[v++] = enif_make_uint64(env, DFLAG_DIST_STRICT_ORDER);
    keys[k++] = ATOM(TERM_TO_BINARY_DFLAGS);
    vals[v++] = enif_make_uint64(env, TERM_TO_BINARY_DFLAGS);

    if (!enif_make_map_from_arrays(env, keys, vals, NUMBER_OF_DISTRIBUTION_FLAGS, &out_term)) {
        return EXCP_ERROR(env, "Call to enif_make_map_from_arrays() failed: duplicate keys detected");
    }

#undef NUMBER_OF_DISTRIBUTION_FLAGS
    return out_term;
}

ERL_NIF_TERM
erldist_filter_nif_spawn_flags_0(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
#define NUMBER_OF_SPAWN_FLAGS (2)
    ERL_NIF_TERM keys[NUMBER_OF_SPAWN_FLAGS];
    ERL_NIF_TERM vals[NUMBER_OF_SPAWN_FLAGS];
    size_t k = 0;
    size_t v = 0;
    ERL_NIF_TERM out_term;

    if (argc != 0) {
        return EXCP_BADARG(env, "argc must be 0");
    }
    keys[k++] = ATOM(ERTS_DIST_SPAWN_FLAG_LINK);
    vals[v++] = enif_make_uint64(env, ERTS_DIST_SPAWN_FLAG_LINK);
    keys[k++] = ATOM(ERTS_DIST_SPAWN_FLAG_MONITOR);
    vals[v++] = enif_make_uint64(env, ERTS_DIST_SPAWN_FLAG_MONITOR);

    if (!enif_make_map_from_arrays(env, keys, vals, NUMBER_OF_SPAWN_FLAGS, &out_term)) {
        return EXCP_ERROR(env, "Call to enif_make_map_from_arrays() failed: duplicate keys detected");
    }

#undef NUMBER_OF_SPAWN_FLAGS
    return out_term;
}